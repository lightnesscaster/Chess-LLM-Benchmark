{% extends "base.html" %}

{% block title %}{{ game.white }} vs {{ game.black }} - LLM Chess Benchmark{% endblock %}

{% block content %}
<div class="game-page">
    <div class="game-header">
        <a href="/games" class="back-link">&larr; Back to Games</a>
        <div class="game-title-row">
            <h1>{{ game.white }} <span class="vs">vs</span> {{ game.black }}</h1>
            <div class="game-result">
                {% if game.winner == 'white' %}
                <span class="result-badge white-win">1-0</span>
                <span class="result-text">White wins by {{ game.termination }}</span>
                {% elif game.winner == 'black' %}
                <span class="result-badge black-win">0-1</span>
                <span class="result-text">Black wins by {{ game.termination }}</span>
                {% else %}
                <span class="result-badge draw">½-½</span>
                <span class="result-text">Draw by {{ game.termination }}</span>
                {% endif %}
            </div>
        </div>
    </div>

    <div class="game-layout">
        <!-- Left: Board and Analysis -->
        <div class="board-column">
            <div class="board-wrapper">
                <div id="board"></div>
            </div>

            <div class="board-toolbar">
                <div class="nav-controls">
                    <button id="btn-start" class="nav-btn" title="Go to start">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6 1.41-1.41M6 6h2v12H6V6z"/></svg>
                    </button>
                    <button id="btn-prev" class="nav-btn" title="Previous move">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/></svg>
                    </button>
                    <span class="move-counter">
                        <span id="current-move">0</span> / <span id="total-moves">{{ ((game.moves|default(0)) + 1) // 2 }}</span>
                    </span>
                    <button id="btn-next" class="nav-btn" title="Next move">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>
                    </button>
                    <button id="btn-end" class="nav-btn" title="Go to end">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6-1.41 1.41M16 6h2v12h-2V6z"/></svg>
                    </button>
                </div>
                <button id="btn-flip" class="flip-btn" title="Flip board">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-4h2v2h-2v-2zm0-2h2V7h-2v7z"/></svg>
                    Flip
                </button>
            </div>

            <button id="btn-analysis" class="analysis-btn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14H6v-2h6v2zm4-4H6v-2h10v2zm0-4H6V7h10v2z"/></svg>
                <span>Stockfish Analysis</span>
            </button>

            <div id="analysis-panel" class="analysis-panel" style="display: none;">
                <div class="analysis-header">
                    <span class="analysis-title">Stockfish 16</span>
                    <span id="analysis-depth" class="analysis-depth"></span>
                </div>
                <div class="analysis-content">
                    <div id="eval-bar-container" class="eval-bar-container">
                        <div id="eval-bar" class="eval-bar">
                            <div id="eval-bar-fill" class="eval-bar-fill"></div>
                        </div>
                        <span id="eval-score" class="eval-score">0.00</span>
                    </div>
                    <div id="analysis-lines" class="analysis-lines">
                        <div class="analysis-loading">Click to enable analysis</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right: Game Info and Moves -->
        <div class="info-column">
            <div class="game-meta">
                <div class="meta-grid">
                    <div class="meta-item">
                        <span class="meta-label">White</span>
                        <span class="meta-value player-white">{{ game.white }}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Black</span>
                        <span class="meta-value player-black">{{ game.black }}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Date</span>
                        <span class="meta-value">{{ game.created_at[:10] if game.created_at else 'N/A' }}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Moves</span>
                        <span class="meta-value">{{ ((game.moves|default(0)) + 1) // 2 }}</span>
                    </div>
                    {% if game.illegal_moves_white|default(0) > 0 or game.illegal_moves_black|default(0) > 0 %}
                    <div class="meta-item illegal">
                        <span class="meta-label">Illegal Moves</span>
                        <span class="meta-value">W: {{ game.illegal_moves_white|default(0) }} / B: {{ game.illegal_moves_black|default(0) }}</span>
                    </div>
                    {% endif %}
                </div>
            </div>

            <div class="moves-panel">
                <div class="panel-header">
                    <h3>Moves</h3>
                </div>
                <div id="moves-container" class="moves-container"></div>
            </div>

            <div class="pgn-panel">
                <button class="pgn-toggle" id="pgn-toggle">
                    <span>PGN</span>
                    <svg class="pgn-chevron" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>
                </button>
                <div class="pgn-content" id="pgn-content" style="display: none;">
                    <pre class="pgn-text">{{ game.pgn }}</pre>
                    <button class="copy-btn" id="copy-pgn" title="Copy PGN">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                        Copy
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const pgn = {{ game.pgn|tojson }};
    const movesContainer = document.getElementById('moves-container');

    // Initialize board
    let currentPosition = 0;
    let flipped = false;
    let positions = ['rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1']; // Starting position
    let moves = [];

    // Analysis state
    let analysisEnabled = false;
    let analysisCache = {};
    let stockfish = null;
    let currentAnalysisFen = null;
    let currentAnalysisId = 0;
    let analysisLines = [{}, {}, {}]; // Store 3 lines of analysis

    // Cleanup worker on page unload
    window.addEventListener('beforeunload', () => {
        if (stockfish) {
            stockfish.terminate();
            stockfish = null;
        }
    });

    const board = Chessboard('board', {
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    });

    // PGN toggle functionality
    const pgnToggle = document.getElementById('pgn-toggle');
    const pgnContent = document.getElementById('pgn-content');
    pgnToggle.addEventListener('click', () => {
        const isExpanded = pgnContent.style.display !== 'none';
        pgnContent.style.display = isExpanded ? 'none' : 'block';
        pgnToggle.classList.toggle('expanded', !isExpanded);
    });

    // Copy PGN functionality
    document.getElementById('copy-pgn').addEventListener('click', () => {
        navigator.clipboard.writeText(pgn).then(() => {
            const btn = document.getElementById('copy-pgn');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Copied!';
            setTimeout(() => { btn.innerHTML = originalHTML; }, 2000);
        });
    });

    try {
        // Parse PGN to extract moves
        const chess = new Chess();
        positions = [chess.fen()];

        // Extract just the moves part (after headers)
        const pgnLines = pgn.split('\n');
        let movesText = '';
        let inMoves = false;

        for (const line of pgnLines) {
            if (line.startsWith('[')) continue;
            if (line.trim() === '') {
                inMoves = true;
                continue;
            }
            if (inMoves) {
                movesText += ' ' + line;
            }
        }

        // Parse moves
        const moveRegex = /(\d+)\.\s*(\S+)(?:\s+(\S+))?/g;
        let match;

        while ((match = moveRegex.exec(movesText)) !== null) {
            const whiteMove = match[2];
            const blackMove = match[3];

            // Skip result markers
            if (whiteMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(whiteMove)) {
                const result = chess.move(whiteMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'w', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }

            if (blackMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(blackMove)) {
                const result = chess.move(blackMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'b', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }
        }

        // Render moves list
        let html = '<table class="moves-table"><tbody>';

        for (let i = 0; i < moves.length; i++) {
            const move = moves[i];
            if (move.color === 'w') {
                html += `<tr><td class="move-num">${move.moveNum}.</td>`;
                html += `<td class="move white-move" data-index="${i+1}">${move.san}</td>`;
            } else {
                html += `<td class="move black-move" data-index="${i+1}">${move.san}</td></tr>`;
            }
        }

        // Handle odd number of moves (white's last move without black response)
        if (moves.length > 0 && moves[moves.length - 1].color === 'w') {
            html += '<td></td></tr>';
        }

        html += '</tbody></table>';
        movesContainer.innerHTML = html;

    } catch (error) {
        console.error('Failed to parse PGN:', error);
        movesContainer.innerHTML = '<p style="color: #e94560;">Error: Unable to parse PGN. The game moves may be corrupted.</p>';
    }

    // Stockfish Web Worker initialization
    async function initStockfish() {
        if (stockfish) return;

        const linesContainer = document.getElementById('analysis-lines');
        linesContainer.innerHTML = '<div class="analysis-loading">Loading Stockfish...</div>';

        // Load Stockfish 16 from CDN (single WASM file, simple structure)
        const STOCKFISH_BASE = 'https://unpkg.com/stockfish@16.0.0/src/';
        const STOCKFISH_JS_URL = STOCKFISH_BASE + 'stockfish-nnue-16-single.js';

        let scriptBlob;
        try {
            const response = await fetch(STOCKFISH_JS_URL);
            if (!response.ok) throw new Error('Failed to fetch Stockfish');
            let scriptText = await response.text();

            // Replace relative WASM/NNUE paths with absolute CDN URLs
            scriptText = scriptText.replace(
                /(["'`])([a-zA-Z0-9_-]+\.(wasm|nnue))\1/g,
                (match, quote, filename) => `${quote}${STOCKFISH_BASE}${filename}${quote}`
            );
            console.log('Patched WASM/NNUE paths to use CDN');

            scriptBlob = new Blob([scriptText], { type: 'application/javascript' });
        } catch (error) {
            console.error('Failed to download Stockfish:', error);
            linesContainer.innerHTML = '<div class="analysis-error">Failed to download engine</div>';
            throw error;
        }

        const blobUrl = URL.createObjectURL(scriptBlob);

        return new Promise((resolve, reject) => {
            // Timeout for initialization (15 seconds)
            let initTimeout = setTimeout(() => {
                currentAnalysisFen = null;
                analysisLines = [{}, {}, {}];
                if (stockfish) {
                    stockfish.terminate();
                    stockfish = null;
                }
                URL.revokeObjectURL(blobUrl);
                linesContainer.innerHTML = '<div class="analysis-error">Engine load timeout. Try refreshing.</div>';
                reject(new Error('Stockfish initialization timeout'));
            }, 15000);

            try {
                // Create worker from patched Stockfish script
                stockfish = new Worker(blobUrl);
                URL.revokeObjectURL(blobUrl);

                stockfish.onmessage = function(event) {
                    const line = event.data;

                    // Handle UCI initialization
                    if (line === 'uciok') {
                        stockfish.postMessage('setoption name MultiPV value 3');
                        stockfish.postMessage('isready');
                    } else if (line === 'readyok') {
                        clearTimeout(initTimeout);
                        resolve();
                    } else {
                        handleStockfishOutput(line);
                    }
                };

                stockfish.onerror = function(error) {
                    clearTimeout(initTimeout);
                    console.error('Stockfish error:', error);
                    linesContainer.innerHTML = '<div class="analysis-error">Failed to load engine</div>';
                    currentAnalysisFen = null;
                    analysisLines = [{}, {}, {}];
                    if (stockfish) {
                        stockfish.terminate();
                        stockfish = null;
                    }
                    reject(error);
                };

                // Initialize UCI
                stockfish.postMessage('uci');
            } catch (error) {
                clearTimeout(initTimeout);
                console.error('Failed to create worker:', error);
                linesContainer.innerHTML = '<div class="analysis-error">Browser not supported</div>';
                URL.revokeObjectURL(blobUrl);
                reject(error);
            }
        });
    }

    // Parse Stockfish UCI output
    function handleStockfishOutput(line) {
        if (!line.startsWith('info depth')) return;
        if (line.includes('currmove')) return; // Skip current move updates

        // Parse the info line
        const depthMatch = line.match(/depth (\d+)/);
        const multipvMatch = line.match(/multipv (\d+)/);
        const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
        const pvMatch = line.match(/ pv (.+)/);

        if (!depthMatch || !scoreMatch || !pvMatch) return;

        const depth = parseInt(depthMatch[1]);
        const multipv = multipvMatch ? parseInt(multipvMatch[1]) : 1;
        const scoreType = scoreMatch[1];
        const scoreValue = parseInt(scoreMatch[2]);
        const pvUci = pvMatch[1].split(' ');

        // Validate multipv is in expected range (1-3)
        if (multipv < 1 || multipv > 3) return;

        // Check this is still the current analysis (race condition prevention)
        if (!currentAnalysisFen) return;
        const { fen, id } = currentAnalysisFen;
        if (id !== currentAnalysisId) return; // Stale result, ignore

        // Convert UCI moves to SAN using chess.js
        let tempChess;
        try {
            tempChess = new Chess(fen);
        } catch (e) {
            console.error('Invalid FEN:', fen);
            return;
        }

        const pvSan = [];
        for (const uci of pvUci.slice(0, 10)) {
            try {
                const move = tempChess.move(uci, { sloppy: true });
                if (move) {
                    pvSan.push(move.san);
                } else {
                    break;
                }
            } catch (e) {
                break;
            }
        }

        // Build line data - convert score to White's perspective
        // Stockfish returns score from side-to-move's perspective
        const isBlackToMove = fen.split(' ')[1] === 'b';
        const flipScore = isBlackToMove ? -1 : 1;

        let score_cp = null;
        let mate = null;
        let score_text = '';

        if (scoreType === 'mate') {
            mate = scoreValue * flipScore;
            score_text = mate > 0 ? `M${mate}` : `-M${Math.abs(mate)}`;
        } else {
            score_cp = scoreValue * flipScore;
            score_text = (score_cp / 100).toFixed(2);
            if (score_cp > 0) score_text = '+' + score_text;
        }

        // Store in analysis lines (multipv is 1-indexed)
        analysisLines[multipv - 1] = {
            score_cp,
            mate,
            score_text,
            pv: pvSan,
            depth
        };

        // Update display with current analysis
        displayAnalysis({
            depth,
            lines: analysisLines.filter(l => l.pv && l.pv.length > 0)
        });

        // Cache when we reach target depth
        if (depth >= 22 && multipv === 1) {
            analysisCache[fen] = {
                depth,
                lines: analysisLines.filter(l => l.pv && l.pv.length > 0).map(l => ({...l}))
            };
        }
    }

    function updateEvalBar(score_cp, mate) {
        const evalBarFill = document.getElementById('eval-bar-fill');
        const evalScore = document.getElementById('eval-score');

        let percentage, displayScore;

        if (mate !== null && mate !== undefined) {
            // Mate score
            percentage = mate > 0 ? 100 : 0;
            displayScore = mate > 0 ? `M${mate}` : `-M${Math.abs(mate)}`;
        } else if (score_cp !== null && score_cp !== undefined) {
            // Convert centipawns to percentage
            const capped = Math.max(-1000, Math.min(1000, score_cp));
            percentage = 50 + (capped / 20);
            percentage = Math.max(0, Math.min(100, percentage));
            displayScore = (score_cp / 100).toFixed(2);
            if (score_cp > 0) displayScore = '+' + displayScore;
        } else {
            percentage = 50;
            displayScore = '0.00';
        }

        evalBarFill.style.height = percentage + '%';
        evalScore.textContent = displayScore;
    }

    function displayAnalysis(analysis) {
        const linesContainer = document.getElementById('analysis-lines');
        const depthSpan = document.getElementById('analysis-depth');

        if (!analysis || !analysis.lines || analysis.lines.length === 0) {
            return; // Keep showing loading or previous state
        }

        depthSpan.textContent = `Depth ${analysis.depth}`;

        // Update eval bar with best line score
        const bestLine = analysis.lines[0];
        updateEvalBar(bestLine.score_cp, bestLine.mate);

        // Display lines
        let html = '';
        analysis.lines.forEach((line) => {
            const pvText = line.pv.join(' ');
            html += `
                <div class="analysis-line">
                    <span class="line-score">${line.score_text}</span>
                    <span class="line-pv">${pvText}</span>
                </div>
            `;
        });

        linesContainer.innerHTML = html;
    }

    async function runAnalysis() {
        if (!analysisEnabled || !stockfish) return;

        const fen = positions[currentPosition];

        // Check cache first
        if (analysisCache[fen]) {
            displayAnalysis(analysisCache[fen]);
            return;
        }

        // Stop previous analysis
        stockfish.postMessage('stop');

        // Increment analysis ID to invalidate stale results
        currentAnalysisId++;

        // Reset analysis lines
        analysisLines = [{}, {}, {}];
        currentAnalysisFen = { fen, id: currentAnalysisId };

        // Show loading state
        const linesContainer = document.getElementById('analysis-lines');
        linesContainer.innerHTML = '<div class="analysis-loading">Analyzing...</div>';
        document.getElementById('analysis-depth').textContent = '';

        // Start new analysis
        stockfish.postMessage('position fen ' + fen);
        stockfish.postMessage('go depth 25');
    }

    async function toggleAnalysis() {
        const panel = document.getElementById('analysis-panel');
        const btn = document.getElementById('btn-analysis');

        if (!analysisEnabled) {
            // Enable analysis
            panel.style.display = 'block';
            btn.classList.add('active');

            try {
                await initStockfish();
                analysisEnabled = true;
                runAnalysis();
            } catch (error) {
                console.error('Failed to initialize Stockfish:', error);
                panel.style.display = 'none';
                btn.classList.remove('active');
            }
        } else {
            // Disable analysis
            analysisEnabled = false;
            panel.style.display = 'none';
            btn.classList.remove('active');
            currentAnalysisFen = null;
            analysisLines = [{}, {}, {}];
            if (stockfish) {
                stockfish.postMessage('stop');
                stockfish.terminate();
                stockfish = null;
            }
        }
    }

    // Update display
    function updateDisplay() {
        board.position(positions[currentPosition]);
        // Show full move number (not half-moves)
        document.getElementById('current-move').textContent = Math.ceil(currentPosition / 2);

        // Highlight current move in list
        document.querySelectorAll('.move').forEach(el => el.classList.remove('current'));
        if (currentPosition > 0) {
            const currentEl = document.querySelector(`.move[data-index="${currentPosition}"]`);
            if (currentEl) {
                currentEl.classList.add('current');
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Run analysis if enabled
        if (analysisEnabled) {
            runAnalysis();
        }
    }

    // Controls
    document.getElementById('btn-start').addEventListener('click', () => {
        currentPosition = 0;
        updateDisplay();
    });

    document.getElementById('btn-prev').addEventListener('click', () => {
        if (currentPosition > 0) {
            currentPosition--;
            updateDisplay();
        }
    });

    document.getElementById('btn-next').addEventListener('click', () => {
        if (currentPosition < positions.length - 1) {
            currentPosition++;
            updateDisplay();
        }
    });

    document.getElementById('btn-end').addEventListener('click', () => {
        currentPosition = positions.length - 1;
        updateDisplay();
    });

    document.getElementById('btn-flip').addEventListener('click', () => {
        flipped = !flipped;
        board.orientation(flipped ? 'black' : 'white');
    });

    document.getElementById('btn-analysis').addEventListener('click', toggleAnalysis);

    // Click on moves to navigate
    movesContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('move')) {
            const index = parseInt(e.target.dataset.index);
            if (!isNaN(index)) {
                currentPosition = index;
                updateDisplay();
            }
        }
    });

    // Keyboard navigation (skip if user is typing in an input)
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.key === 'ArrowLeft') {
            if (currentPosition > 0) {
                currentPosition--;
                updateDisplay();
            }
        } else if (e.key === 'ArrowRight') {
            if (currentPosition < positions.length - 1) {
                currentPosition++;
                updateDisplay();
            }
        } else if (e.key === 'Home') {
            currentPosition = 0;
            updateDisplay();
        } else if (e.key === 'End') {
            currentPosition = positions.length - 1;
            updateDisplay();
        }
    });

    // Set total moves (full moves, not half-moves)
    document.getElementById('total-moves').textContent = Math.ceil((positions.length - 1) / 2);
});
</script>
{% endblock %}
