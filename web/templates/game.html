{% extends "base.html" %}

{% block title %}{{ game.white }} vs {{ game.black }} - LLM Chess Benchmark{% endblock %}

{% block content %}
<div class="page-header">
    <a href="/games" class="back-link">&larr; Back to Games</a>
    <h1>{{ game.white }} vs {{ game.black }}</h1>
    <p class="subtitle">
        {% if game.winner == 'white' %}
        <span class="result-badge white-win">1-0</span> White wins
        {% elif game.winner == 'black' %}
        <span class="result-badge black-win">0-1</span> Black wins
        {% else %}
        <span class="result-badge draw">½-½</span> Draw
        {% endif %}
        by {{ game.termination }}
    </p>
</div>

<div class="game-viewer">
    <div class="board-section">
        <div id="board" style="width: 400px"></div>
        <div class="board-controls">
            <button id="btn-start" title="Go to start">&lt;&lt;</button>
            <button id="btn-prev" title="Previous move">&lt;</button>
            <button id="btn-next" title="Next move">&gt;</button>
            <button id="btn-end" title="Go to end">&gt;&gt;</button>
            <button id="btn-flip" title="Flip board">Flip</button>
            <button id="btn-analysis" title="Toggle Stockfish analysis">Analysis</button>
        </div>
        <div class="move-indicator">
            Move: <span id="current-move">0</span> / <span id="total-moves">{{ ((game.moves|default(0)) + 1) // 2 }}</span>
        </div>

        <div id="analysis-panel" class="analysis-panel" style="display: none;">
            <div class="analysis-header">
                <span class="analysis-title">Stockfish Analysis</span>
                <span id="analysis-depth" class="analysis-depth"></span>
            </div>
            <div id="eval-bar-container" class="eval-bar-container">
                <div id="eval-bar" class="eval-bar">
                    <div id="eval-bar-fill" class="eval-bar-fill"></div>
                </div>
                <span id="eval-score" class="eval-score">0.00</span>
            </div>
            <div id="analysis-lines" class="analysis-lines">
                <div class="analysis-loading">Click Analysis to enable</div>
            </div>
        </div>
    </div>

    <div class="info-section">
        <div class="game-info">
            <h3>Game Info</h3>
            <table class="info-table">
                <tr>
                    <td>White:</td>
                    <td>{{ game.white }}</td>
                </tr>
                <tr>
                    <td>Black:</td>
                    <td>{{ game.black }}</td>
                </tr>
                <tr>
                    <td>Date:</td>
                    <td>{{ game.created_at[:10] if game.created_at else 'N/A' }}</td>
                </tr>
                <tr>
                    <td>Result:</td>
                    <td>{% if game.winner == 'white' %}1-0{% elif game.winner == 'black' %}0-1{% else %}½-½{% endif %}</td>
                </tr>
                <tr>
                    <td>Termination:</td>
                    <td>{{ game.termination }}</td>
                </tr>
                <tr>
                    <td>Moves:</td>
                    <td>{{ ((game.moves|default(0)) + 1) // 2 }}</td>
                </tr>
                <tr>
                    <td>Illegal (White):</td>
                    <td>{{ game.illegal_moves_white|default(0) }}</td>
                </tr>
                <tr>
                    <td>Illegal (Black):</td>
                    <td>{{ game.illegal_moves_black|default(0) }}</td>
                </tr>
            </table>
        </div>

        <div class="moves-list">
            <h3>Moves</h3>
            <div id="moves-container" class="moves-container"></div>
        </div>
    </div>
</div>

<div class="pgn-section">
    <h3>PGN</h3>
    <pre class="pgn-text">{{ game.pgn }}</pre>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const pgn = {{ game.pgn|tojson }};
    const movesContainer = document.getElementById('moves-container');

    // Initialize board
    let currentPosition = 0;
    let flipped = false;
    let positions = ['rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1']; // Starting position
    let moves = [];

    // Analysis state
    let analysisEnabled = false;
    let analysisCache = {};
    let stockfish = null;
    let currentAnalysisFen = null;
    let currentAnalysisId = 0;
    let analysisLines = [{}, {}, {}]; // Store 3 lines of analysis

    // Cleanup worker on page unload
    window.addEventListener('beforeunload', () => {
        if (stockfish) {
            stockfish.terminate();
            stockfish = null;
        }
    });

    const board = Chessboard('board', {
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    });

    try {
        // Parse PGN to extract moves
        const chess = new Chess();
        positions = [chess.fen()];

        // Extract just the moves part (after headers)
        const pgnLines = pgn.split('\n');
        let movesText = '';
        let inMoves = false;

        for (const line of pgnLines) {
            if (line.startsWith('[')) continue;
            if (line.trim() === '') {
                inMoves = true;
                continue;
            }
            if (inMoves) {
                movesText += ' ' + line;
            }
        }

        // Parse moves
        const moveRegex = /(\d+)\.\s*(\S+)(?:\s+(\S+))?/g;
        let match;

        while ((match = moveRegex.exec(movesText)) !== null) {
            const whiteMove = match[2];
            const blackMove = match[3];

            // Skip result markers
            if (whiteMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(whiteMove)) {
                const result = chess.move(whiteMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'w', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }

            if (blackMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(blackMove)) {
                const result = chess.move(blackMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'b', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }
        }

        // Render moves list
        let html = '<table class="moves-table"><tbody>';

        for (let i = 0; i < moves.length; i++) {
            const move = moves[i];
            if (move.color === 'w') {
                html += `<tr><td class="move-num">${move.moveNum}.</td>`;
                html += `<td class="move white-move" data-index="${i+1}">${move.san}</td>`;
            } else {
                html += `<td class="move black-move" data-index="${i+1}">${move.san}</td></tr>`;
            }
        }

        // Handle odd number of moves (white's last move without black response)
        if (moves.length > 0 && moves[moves.length - 1].color === 'w') {
            html += '<td></td></tr>';
        }

        html += '</tbody></table>';
        movesContainer.innerHTML = html;

    } catch (error) {
        console.error('Failed to parse PGN:', error);
        movesContainer.innerHTML = '<p style="color: #e94560;">Error: Unable to parse PGN. The game moves may be corrupted.</p>';
    }

    // Stockfish Web Worker initialization
    async function initStockfish() {
        if (stockfish) return;

        const linesContainer = document.getElementById('analysis-lines');
        linesContainer.innerHTML = '<div class="analysis-loading">Loading Stockfish...</div>';

        // Fetch the Stockfish script and create a Blob URL to work around CORS
        const STOCKFISH_URL = 'https://cdn.jsdelivr.net/npm/stockfish@16.0.0/src/stockfish-nnue-16-single.js';

        let scriptBlob;
        try {
            const response = await fetch(STOCKFISH_URL);
            if (!response.ok) throw new Error('Failed to fetch Stockfish');
            const scriptText = await response.text();
            scriptBlob = new Blob([scriptText], { type: 'application/javascript' });
        } catch (error) {
            console.error('Failed to download Stockfish:', error);
            linesContainer.innerHTML = '<div class="analysis-error">Failed to download engine</div>';
            throw error;
        }

        const blobUrl = URL.createObjectURL(scriptBlob);

        return new Promise((resolve, reject) => {
            // Timeout for initialization (15 seconds)
            let initTimeout = setTimeout(() => {
                currentAnalysisFen = null;
                analysisLines = [{}, {}, {}];
                if (stockfish) {
                    stockfish.terminate();
                    stockfish = null;
                }
                URL.revokeObjectURL(blobUrl);
                linesContainer.innerHTML = '<div class="analysis-error">Engine load timeout. Try refreshing.</div>';
                reject(new Error('Stockfish initialization timeout'));
            }, 15000);

            try {
                // Create worker from Blob URL
                stockfish = new Worker(blobUrl);

                stockfish.onmessage = function(event) {
                    const line = event.data;

                    // Handle UCI initialization
                    if (line === 'uciok') {
                        stockfish.postMessage('setoption name MultiPV value 3');
                        stockfish.postMessage('isready');
                    } else if (line === 'readyok') {
                        clearTimeout(initTimeout);
                        resolve();
                    } else {
                        handleStockfishOutput(line);
                    }
                };

                stockfish.onerror = function(error) {
                    clearTimeout(initTimeout);
                    console.error('Stockfish error:', error);
                    linesContainer.innerHTML = '<div class="analysis-error">Failed to load engine</div>';
                    currentAnalysisFen = null;
                    analysisLines = [{}, {}, {}];
                    URL.revokeObjectURL(blobUrl);
                    if (stockfish) {
                        stockfish.terminate();
                        stockfish = null;
                    }
                    reject(error);
                };

                // Initialize UCI
                stockfish.postMessage('uci');
            } catch (error) {
                clearTimeout(initTimeout);
                console.error('Failed to create worker:', error);
                linesContainer.innerHTML = '<div class="analysis-error">Browser not supported</div>';
                URL.revokeObjectURL(blobUrl);
                reject(error);
            }
        });
    }

    // Parse Stockfish UCI output
    function handleStockfishOutput(line) {
        if (!line.startsWith('info depth')) return;
        if (line.includes('currmove')) return; // Skip current move updates

        // Parse the info line
        const depthMatch = line.match(/depth (\d+)/);
        const multipvMatch = line.match(/multipv (\d+)/);
        const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
        const pvMatch = line.match(/ pv (.+)/);

        if (!depthMatch || !scoreMatch || !pvMatch) return;

        const depth = parseInt(depthMatch[1]);
        const multipv = multipvMatch ? parseInt(multipvMatch[1]) : 1;
        const scoreType = scoreMatch[1];
        const scoreValue = parseInt(scoreMatch[2]);
        const pvUci = pvMatch[1].split(' ');

        // Validate multipv is in expected range (1-3)
        if (multipv < 1 || multipv > 3) return;

        // Check this is still the current analysis (race condition prevention)
        if (!currentAnalysisFen) return;
        const { fen, id } = currentAnalysisFen;
        if (id !== currentAnalysisId) return; // Stale result, ignore

        // Convert UCI moves to SAN using chess.js
        let tempChess;
        try {
            tempChess = new Chess(fen);
        } catch (e) {
            console.error('Invalid FEN:', fen);
            return;
        }

        const pvSan = [];
        for (const uci of pvUci.slice(0, 10)) {
            try {
                const move = tempChess.move(uci, { sloppy: true });
                if (move) {
                    pvSan.push(move.san);
                } else {
                    break;
                }
            } catch (e) {
                break;
            }
        }

        // Build line data
        let score_cp = null;
        let mate = null;
        let score_text = '';

        if (scoreType === 'mate') {
            mate = scoreValue;
            score_text = scoreValue > 0 ? `M${scoreValue}` : `-M${Math.abs(scoreValue)}`;
        } else {
            score_cp = scoreValue;
            score_text = (scoreValue / 100).toFixed(2);
            if (scoreValue > 0) score_text = '+' + score_text;
        }

        // Store in analysis lines (multipv is 1-indexed)
        analysisLines[multipv - 1] = {
            score_cp,
            mate,
            score_text,
            pv: pvSan,
            depth
        };

        // Update display with current analysis
        displayAnalysis({
            depth,
            lines: analysisLines.filter(l => l.pv && l.pv.length > 0)
        });

        // Cache when we reach target depth
        if (depth >= 18 && multipv === 1) {
            analysisCache[fen] = {
                depth,
                lines: analysisLines.filter(l => l.pv && l.pv.length > 0).map(l => ({...l}))
            };
        }
    }

    function updateEvalBar(score_cp, mate) {
        const evalBarFill = document.getElementById('eval-bar-fill');
        const evalScore = document.getElementById('eval-score');

        let percentage, displayScore;

        if (mate !== null && mate !== undefined) {
            // Mate score
            percentage = mate > 0 ? 100 : 0;
            displayScore = mate > 0 ? `M${mate}` : `-M${Math.abs(mate)}`;
        } else if (score_cp !== null && score_cp !== undefined) {
            // Convert centipawns to percentage
            const capped = Math.max(-1000, Math.min(1000, score_cp));
            percentage = 50 + (capped / 20);
            percentage = Math.max(0, Math.min(100, percentage));
            displayScore = (score_cp / 100).toFixed(2);
            if (score_cp > 0) displayScore = '+' + displayScore;
        } else {
            percentage = 50;
            displayScore = '0.00';
        }

        evalBarFill.style.height = percentage + '%';
        evalScore.textContent = displayScore;
    }

    function displayAnalysis(analysis) {
        const linesContainer = document.getElementById('analysis-lines');
        const depthSpan = document.getElementById('analysis-depth');

        if (!analysis || !analysis.lines || analysis.lines.length === 0) {
            return; // Keep showing loading or previous state
        }

        depthSpan.textContent = `Depth ${analysis.depth}`;

        // Update eval bar with best line score
        const bestLine = analysis.lines[0];
        updateEvalBar(bestLine.score_cp, bestLine.mate);

        // Display lines
        let html = '';
        analysis.lines.forEach((line) => {
            const pvText = line.pv.join(' ');
            html += `
                <div class="analysis-line">
                    <span class="line-score">${line.score_text}</span>
                    <span class="line-pv">${pvText}</span>
                </div>
            `;
        });

        linesContainer.innerHTML = html;
    }

    async function runAnalysis() {
        if (!analysisEnabled || !stockfish) return;

        const fen = positions[currentPosition];

        // Check cache first
        if (analysisCache[fen]) {
            displayAnalysis(analysisCache[fen]);
            return;
        }

        // Stop previous analysis
        stockfish.postMessage('stop');

        // Increment analysis ID to invalidate stale results
        currentAnalysisId++;

        // Reset analysis lines
        analysisLines = [{}, {}, {}];
        currentAnalysisFen = { fen, id: currentAnalysisId };

        // Show loading state
        const linesContainer = document.getElementById('analysis-lines');
        linesContainer.innerHTML = '<div class="analysis-loading">Analyzing...</div>';
        document.getElementById('analysis-depth').textContent = '';

        // Start new analysis
        stockfish.postMessage('position fen ' + fen);
        stockfish.postMessage('go depth 20');
    }

    async function toggleAnalysis() {
        const panel = document.getElementById('analysis-panel');
        const btn = document.getElementById('btn-analysis');

        if (!analysisEnabled) {
            // Enable analysis
            panel.style.display = 'block';
            btn.classList.add('active');

            try {
                await initStockfish();
                analysisEnabled = true;
                runAnalysis();
            } catch (error) {
                console.error('Failed to initialize Stockfish:', error);
                panel.style.display = 'none';
                btn.classList.remove('active');
            }
        } else {
            // Disable analysis
            analysisEnabled = false;
            panel.style.display = 'none';
            btn.classList.remove('active');
            currentAnalysisFen = null;
            analysisLines = [{}, {}, {}];
            if (stockfish) {
                stockfish.postMessage('stop');
                stockfish.terminate();
                stockfish = null;
            }
        }
    }

    // Update display
    function updateDisplay() {
        board.position(positions[currentPosition]);
        // Show full move number (not half-moves)
        document.getElementById('current-move').textContent = Math.ceil(currentPosition / 2);

        // Highlight current move in list
        document.querySelectorAll('.move').forEach(el => el.classList.remove('current'));
        if (currentPosition > 0) {
            const currentEl = document.querySelector(`.move[data-index="${currentPosition}"]`);
            if (currentEl) {
                currentEl.classList.add('current');
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Run analysis if enabled
        if (analysisEnabled) {
            runAnalysis();
        }
    }

    // Controls
    document.getElementById('btn-start').addEventListener('click', () => {
        currentPosition = 0;
        updateDisplay();
    });

    document.getElementById('btn-prev').addEventListener('click', () => {
        if (currentPosition > 0) {
            currentPosition--;
            updateDisplay();
        }
    });

    document.getElementById('btn-next').addEventListener('click', () => {
        if (currentPosition < positions.length - 1) {
            currentPosition++;
            updateDisplay();
        }
    });

    document.getElementById('btn-end').addEventListener('click', () => {
        currentPosition = positions.length - 1;
        updateDisplay();
    });

    document.getElementById('btn-flip').addEventListener('click', () => {
        flipped = !flipped;
        board.orientation(flipped ? 'black' : 'white');
    });

    document.getElementById('btn-analysis').addEventListener('click', toggleAnalysis);

    // Click on moves to navigate
    movesContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('move')) {
            const index = parseInt(e.target.dataset.index);
            if (!isNaN(index)) {
                currentPosition = index;
                updateDisplay();
            }
        }
    });

    // Keyboard navigation (skip if user is typing in an input)
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.key === 'ArrowLeft') {
            if (currentPosition > 0) {
                currentPosition--;
                updateDisplay();
            }
        } else if (e.key === 'ArrowRight') {
            if (currentPosition < positions.length - 1) {
                currentPosition++;
                updateDisplay();
            }
        } else if (e.key === 'Home') {
            currentPosition = 0;
            updateDisplay();
        } else if (e.key === 'End') {
            currentPosition = positions.length - 1;
            updateDisplay();
        }
    });

    // Set total moves (full moves, not half-moves)
    document.getElementById('total-moves').textContent = Math.ceil((positions.length - 1) / 2);
});
</script>
{% endblock %}
