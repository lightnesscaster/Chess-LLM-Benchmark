{% extends "base.html" %}

{% block title %}{{ game.white }} vs {{ game.black }} - LLM Chess Benchmark{% endblock %}

{% block content %}
<div class="page-header">
    <a href="/games" class="back-link">&larr; Back to Games</a>
    <h1>{{ game.white }} vs {{ game.black }}</h1>
    <p class="subtitle">
        {% if game.winner == 'white' %}
        <span class="result-badge white-win">1-0</span> White wins
        {% elif game.winner == 'black' %}
        <span class="result-badge black-win">0-1</span> Black wins
        {% else %}
        <span class="result-badge draw">½-½</span> Draw
        {% endif %}
        by {{ game.termination }}
    </p>
</div>

<div class="game-viewer">
    <div class="board-section">
        <div id="board" style="width: 400px"></div>
        <div class="board-controls">
            <button id="btn-start" title="Go to start">&lt;&lt;</button>
            <button id="btn-prev" title="Previous move">&lt;</button>
            <button id="btn-next" title="Next move">&gt;</button>
            <button id="btn-end" title="Go to end">&gt;&gt;</button>
            <button id="btn-flip" title="Flip board">Flip</button>
            <button id="btn-analysis" title="Toggle Stockfish analysis">Analysis</button>
        </div>
        <div class="move-indicator">
            Move: <span id="current-move">0</span> / <span id="total-moves">{{ ((game.moves|default(0)) + 1) // 2 }}</span>
        </div>

        <div id="analysis-panel" class="analysis-panel" style="display: none;">
            <div class="analysis-header">
                <span class="analysis-title">Stockfish Analysis</span>
                <span id="analysis-depth" class="analysis-depth"></span>
            </div>
            <div id="eval-bar-container" class="eval-bar-container">
                <div id="eval-bar" class="eval-bar">
                    <div id="eval-bar-fill" class="eval-bar-fill"></div>
                </div>
                <span id="eval-score" class="eval-score">0.00</span>
            </div>
            <div id="analysis-lines" class="analysis-lines">
                <div class="analysis-loading">Click Analysis to enable</div>
            </div>
        </div>
    </div>

    <div class="info-section">
        <div class="game-info">
            <h3>Game Info</h3>
            <table class="info-table">
                <tr>
                    <td>White:</td>
                    <td>{{ game.white }}</td>
                </tr>
                <tr>
                    <td>Black:</td>
                    <td>{{ game.black }}</td>
                </tr>
                <tr>
                    <td>Date:</td>
                    <td>{{ game.created_at[:10] if game.created_at else 'N/A' }}</td>
                </tr>
                <tr>
                    <td>Result:</td>
                    <td>{% if game.winner == 'white' %}1-0{% elif game.winner == 'black' %}0-1{% else %}½-½{% endif %}</td>
                </tr>
                <tr>
                    <td>Termination:</td>
                    <td>{{ game.termination }}</td>
                </tr>
                <tr>
                    <td>Moves:</td>
                    <td>{{ ((game.moves|default(0)) + 1) // 2 }}</td>
                </tr>
                <tr>
                    <td>Illegal (White):</td>
                    <td>{{ game.illegal_moves_white|default(0) }}</td>
                </tr>
                <tr>
                    <td>Illegal (Black):</td>
                    <td>{{ game.illegal_moves_black|default(0) }}</td>
                </tr>
            </table>
        </div>

        <div class="moves-list">
            <h3>Moves</h3>
            <div id="moves-container" class="moves-container"></div>
        </div>
    </div>
</div>

<div class="pgn-section">
    <h3>PGN</h3>
    <pre class="pgn-text">{{ game.pgn }}</pre>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const pgn = {{ game.pgn|tojson }};
    const movesContainer = document.getElementById('moves-container');

    // Initialize board
    let currentPosition = 0;
    let flipped = false;
    let positions = ['rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1']; // Starting position
    let moves = [];

    // Analysis state
    let analysisEnabled = false;
    let analysisCache = {};
    let currentAnalysisRequest = null;

    const board = Chessboard('board', {
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    });

    try {
        // Parse PGN to extract moves
        const chess = new Chess();
        positions = [chess.fen()];

        // Extract just the moves part (after headers)
        const pgnLines = pgn.split('\n');
        let movesText = '';
        let inMoves = false;

        for (const line of pgnLines) {
            if (line.startsWith('[')) continue;
            if (line.trim() === '') {
                inMoves = true;
                continue;
            }
            if (inMoves) {
                movesText += ' ' + line;
            }
        }

        // Parse moves
        const moveRegex = /(\d+)\.\s*(\S+)(?:\s+(\S+))?/g;
        let match;

        while ((match = moveRegex.exec(movesText)) !== null) {
            const whiteMove = match[2];
            const blackMove = match[3];

            // Skip result markers
            if (whiteMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(whiteMove)) {
                const result = chess.move(whiteMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'w', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }

            if (blackMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(blackMove)) {
                const result = chess.move(blackMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'b', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }
        }

        // Render moves list
        let html = '<table class="moves-table"><tbody>';

        for (let i = 0; i < moves.length; i++) {
            const move = moves[i];
            if (move.color === 'w') {
                html += `<tr><td class="move-num">${move.moveNum}.</td>`;
                html += `<td class="move white-move" data-index="${i+1}">${move.san}</td>`;
            } else {
                html += `<td class="move black-move" data-index="${i+1}">${move.san}</td></tr>`;
            }
        }

        // Handle odd number of moves (white's last move without black response)
        if (moves.length > 0 && moves[moves.length - 1].color === 'w') {
            html += '<td></td></tr>';
        }

        html += '</tbody></table>';
        movesContainer.innerHTML = html;

    } catch (error) {
        console.error('Failed to parse PGN:', error);
        movesContainer.innerHTML = '<p style="color: #e94560;">Error: Unable to parse PGN. The game moves may be corrupted.</p>';
    }

    // Analysis functions
    async function fetchAnalysis(fen) {
        // Check cache first
        if (analysisCache[fen]) {
            return analysisCache[fen];
        }

        try {
            const response = await fetch('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fen: fen, depth: 18, lines: 3 })
            });

            if (!response.ok) {
                throw new Error('Analysis failed');
            }

            const data = await response.json();
            analysisCache[fen] = data;
            return data;
        } catch (error) {
            console.error('Analysis error:', error);
            return null;
        }
    }

    function updateEvalBar(score_cp, mate) {
        const evalBarFill = document.getElementById('eval-bar-fill');
        const evalScore = document.getElementById('eval-score');

        let percentage, displayScore;

        if (mate !== null) {
            // Mate score
            percentage = mate > 0 ? 100 : 0;
            displayScore = mate > 0 ? `M${mate}` : `M${mate}`;
        } else if (score_cp !== null) {
            // Convert centipawns to percentage (sigmoid-like scaling)
            // Cap at roughly ±10 pawns for display
            const capped = Math.max(-1000, Math.min(1000, score_cp));
            percentage = 50 + (capped / 20); // Each pawn = 5% shift
            percentage = Math.max(0, Math.min(100, percentage));
            displayScore = (score_cp / 100).toFixed(2);
            if (score_cp > 0) displayScore = '+' + displayScore;
        } else {
            percentage = 50;
            displayScore = '0.00';
        }

        evalBarFill.style.height = percentage + '%';
        evalScore.textContent = displayScore;
    }

    function displayAnalysis(analysis) {
        const linesContainer = document.getElementById('analysis-lines');
        const depthSpan = document.getElementById('analysis-depth');

        if (!analysis) {
            linesContainer.innerHTML = '<div class="analysis-error">Analysis unavailable</div>';
            return;
        }

        depthSpan.textContent = `Depth ${analysis.depth}`;

        // Update eval bar with best line score
        if (analysis.lines.length > 0) {
            const bestLine = analysis.lines[0];
            updateEvalBar(bestLine.score_cp, bestLine.mate);
        }

        // Display lines
        let html = '';
        analysis.lines.forEach((line, index) => {
            const pvText = line.pv.join(' ');
            html += `
                <div class="analysis-line">
                    <span class="line-score">${line.score_text}</span>
                    <span class="line-pv">${pvText}</span>
                </div>
            `;
        });

        linesContainer.innerHTML = html;
    }

    async function runAnalysis() {
        if (!analysisEnabled) return;

        const fen = positions[currentPosition];
        const linesContainer = document.getElementById('analysis-lines');

        // Show loading state
        linesContainer.innerHTML = '<div class="analysis-loading">Analyzing...</div>';

        // Cancel any pending request tracking
        const requestId = Date.now();
        currentAnalysisRequest = requestId;

        const analysis = await fetchAnalysis(fen);

        // Only update if this is still the current request
        if (currentAnalysisRequest === requestId) {
            displayAnalysis(analysis);
        }
    }

    function toggleAnalysis() {
        analysisEnabled = !analysisEnabled;
        const panel = document.getElementById('analysis-panel');
        const btn = document.getElementById('btn-analysis');

        if (analysisEnabled) {
            panel.style.display = 'block';
            btn.classList.add('active');
            runAnalysis();
        } else {
            panel.style.display = 'none';
            btn.classList.remove('active');
        }
    }

    // Update display
    function updateDisplay() {
        board.position(positions[currentPosition]);
        // Show full move number (not half-moves)
        document.getElementById('current-move').textContent = Math.ceil(currentPosition / 2);

        // Highlight current move in list
        document.querySelectorAll('.move').forEach(el => el.classList.remove('current'));
        if (currentPosition > 0) {
            const currentEl = document.querySelector(`.move[data-index="${currentPosition}"]`);
            if (currentEl) {
                currentEl.classList.add('current');
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Run analysis if enabled
        if (analysisEnabled) {
            runAnalysis();
        }
    }

    // Controls
    document.getElementById('btn-start').addEventListener('click', () => {
        currentPosition = 0;
        updateDisplay();
    });

    document.getElementById('btn-prev').addEventListener('click', () => {
        if (currentPosition > 0) {
            currentPosition--;
            updateDisplay();
        }
    });

    document.getElementById('btn-next').addEventListener('click', () => {
        if (currentPosition < positions.length - 1) {
            currentPosition++;
            updateDisplay();
        }
    });

    document.getElementById('btn-end').addEventListener('click', () => {
        currentPosition = positions.length - 1;
        updateDisplay();
    });

    document.getElementById('btn-flip').addEventListener('click', () => {
        flipped = !flipped;
        board.orientation(flipped ? 'black' : 'white');
    });

    document.getElementById('btn-analysis').addEventListener('click', toggleAnalysis);

    // Click on moves to navigate
    movesContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('move')) {
            const index = parseInt(e.target.dataset.index);
            if (!isNaN(index)) {
                currentPosition = index;
                updateDisplay();
            }
        }
    });

    // Keyboard navigation (skip if user is typing in an input)
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.key === 'ArrowLeft') {
            if (currentPosition > 0) {
                currentPosition--;
                updateDisplay();
            }
        } else if (e.key === 'ArrowRight') {
            if (currentPosition < positions.length - 1) {
                currentPosition++;
                updateDisplay();
            }
        } else if (e.key === 'Home') {
            currentPosition = 0;
            updateDisplay();
        } else if (e.key === 'End') {
            currentPosition = positions.length - 1;
            updateDisplay();
        }
    });

    // Set total moves (full moves, not half-moves)
    document.getElementById('total-moves').textContent = Math.ceil((positions.length - 1) / 2);
});
</script>
{% endblock %}
