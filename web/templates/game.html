{% extends "base.html" %}

{% block title %}{{ game.white }} vs {{ game.black }} - LLM Chess Benchmark{% endblock %}

{% block content %}
<div class="page-header">
    <a href="/games" class="back-link">&larr; Back to Games</a>
    <h1>{{ game.white }} vs {{ game.black }}</h1>
    <p class="subtitle">
        {% if game.winner == 'white' %}
        <span class="result-badge white-win">1-0</span> White wins
        {% elif game.winner == 'black' %}
        <span class="result-badge black-win">0-1</span> Black wins
        {% else %}
        <span class="result-badge draw">½-½</span> Draw
        {% endif %}
        by {{ game.termination }}
    </p>
</div>

<div class="game-viewer">
    <div class="board-section">
        <div id="board" style="width: 400px"></div>
        <div class="board-controls">
            <button id="btn-start" title="Go to start">&lt;&lt;</button>
            <button id="btn-prev" title="Previous move">&lt;</button>
            <button id="btn-next" title="Next move">&gt;</button>
            <button id="btn-end" title="Go to end">&gt;&gt;</button>
            <button id="btn-flip" title="Flip board">Flip</button>
        </div>
        <div class="move-indicator">
            Move: <span id="current-move">0</span> / <span id="total-moves">{{ ((game.moves|default(0)) + 1) // 2 }}</span>
        </div>
    </div>

    <div class="info-section">
        <div class="game-info">
            <h3>Game Info</h3>
            <table class="info-table">
                <tr>
                    <td>White:</td>
                    <td>{{ game.white }}</td>
                </tr>
                <tr>
                    <td>Black:</td>
                    <td>{{ game.black }}</td>
                </tr>
                <tr>
                    <td>Date:</td>
                    <td>{{ game.created_at[:10] if game.created_at else 'N/A' }}</td>
                </tr>
                <tr>
                    <td>Result:</td>
                    <td>{% if game.winner == 'white' %}1-0{% elif game.winner == 'black' %}0-1{% else %}½-½{% endif %}</td>
                </tr>
                <tr>
                    <td>Termination:</td>
                    <td>{{ game.termination }}</td>
                </tr>
                <tr>
                    <td>Moves:</td>
                    <td>{{ ((game.moves|default(0)) + 1) // 2 }}</td>
                </tr>
                <tr>
                    <td>Illegal (White):</td>
                    <td>{{ game.illegal_moves_white|default(0) }}</td>
                </tr>
                <tr>
                    <td>Illegal (Black):</td>
                    <td>{{ game.illegal_moves_black|default(0) }}</td>
                </tr>
            </table>
        </div>

        <div class="moves-list">
            <h3>Moves</h3>
            <div id="moves-container" class="moves-container"></div>
        </div>
    </div>
</div>

<div class="pgn-section">
    <h3>PGN</h3>
    <pre class="pgn-text">{{ game.pgn }}</pre>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const pgn = {{ game.pgn|tojson }};
    const movesContainer = document.getElementById('moves-container');

    // Initialize board
    let currentPosition = 0;
    let flipped = false;
    let positions = ['rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1']; // Starting position
    let moves = [];

    const board = Chessboard('board', {
        position: 'start',
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    });

    try {
        // Parse PGN to extract moves
        const chess = new Chess();
        positions = [chess.fen()];

        // Extract just the moves part (after headers)
        const pgnLines = pgn.split('\n');
        let movesText = '';
        let inMoves = false;

        for (const line of pgnLines) {
            if (line.startsWith('[')) continue;
            if (line.trim() === '') {
                inMoves = true;
                continue;
            }
            if (inMoves) {
                movesText += ' ' + line;
            }
        }

        // Parse moves
        const moveRegex = /(\d+)\.\s*(\S+)(?:\s+(\S+))?/g;
        let match;

        while ((match = moveRegex.exec(movesText)) !== null) {
            const whiteMove = match[2];
            const blackMove = match[3];

            // Skip result markers
            if (whiteMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(whiteMove)) {
                const result = chess.move(whiteMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'w', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }

            if (blackMove && !['1-0', '0-1', '1/2-1/2', '*'].includes(blackMove)) {
                const result = chess.move(blackMove, { sloppy: true });
                if (result) {
                    moves.push({ san: result.san, color: 'b', moveNum: match[1] });
                    positions.push(chess.fen());
                }
            }
        }

        // Render moves list
        let html = '<table class="moves-table"><tbody>';

        for (let i = 0; i < moves.length; i++) {
            const move = moves[i];
            if (move.color === 'w') {
                html += `<tr><td class="move-num">${move.moveNum}.</td>`;
                html += `<td class="move white-move" data-index="${i+1}">${move.san}</td>`;
            } else {
                html += `<td class="move black-move" data-index="${i+1}">${move.san}</td></tr>`;
            }
        }

        // Handle odd number of moves (white's last move without black response)
        if (moves.length > 0 && moves[moves.length - 1].color === 'w') {
            html += '<td></td></tr>';
        }

        html += '</tbody></table>';
        movesContainer.innerHTML = html;

    } catch (error) {
        console.error('Failed to parse PGN:', error);
        movesContainer.innerHTML = '<p style="color: #e94560;">Error: Unable to parse PGN. The game moves may be corrupted.</p>';
    }

    // Update display
    function updateDisplay() {
        board.position(positions[currentPosition]);
        // Show full move number (not half-moves)
        document.getElementById('current-move').textContent = Math.ceil(currentPosition / 2);

        // Highlight current move in list
        document.querySelectorAll('.move').forEach(el => el.classList.remove('current'));
        if (currentPosition > 0) {
            const currentEl = document.querySelector(`.move[data-index="${currentPosition}"]`);
            if (currentEl) {
                currentEl.classList.add('current');
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
    }

    // Controls
    document.getElementById('btn-start').addEventListener('click', () => {
        currentPosition = 0;
        updateDisplay();
    });

    document.getElementById('btn-prev').addEventListener('click', () => {
        if (currentPosition > 0) {
            currentPosition--;
            updateDisplay();
        }
    });

    document.getElementById('btn-next').addEventListener('click', () => {
        if (currentPosition < positions.length - 1) {
            currentPosition++;
            updateDisplay();
        }
    });

    document.getElementById('btn-end').addEventListener('click', () => {
        currentPosition = positions.length - 1;
        updateDisplay();
    });

    document.getElementById('btn-flip').addEventListener('click', () => {
        flipped = !flipped;
        board.orientation(flipped ? 'black' : 'white');
    });

    // Click on moves to navigate
    movesContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('move')) {
            const index = parseInt(e.target.dataset.index);
            if (!isNaN(index)) {
                currentPosition = index;
                updateDisplay();
            }
        }
    });

    // Keyboard navigation (skip if user is typing in an input)
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.key === 'ArrowLeft') {
            if (currentPosition > 0) {
                currentPosition--;
                updateDisplay();
            }
        } else if (e.key === 'ArrowRight') {
            if (currentPosition < positions.length - 1) {
                currentPosition++;
                updateDisplay();
            }
        } else if (e.key === 'Home') {
            currentPosition = 0;
            updateDisplay();
        } else if (e.key === 'End') {
            currentPosition = positions.length - 1;
            updateDisplay();
        }
    });

    // Set total moves (full moves, not half-moves)
    document.getElementById('total-moves').textContent = Math.ceil((positions.length - 1) / 2);
});
</script>
{% endblock %}
